{"version":3,"file":"1905-e1d22eac1c5e93f7c1be.js","mappings":"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","sources":["webpack://embla-carousel-docs/../src/components/Options.ts","webpack://embla-carousel-docs/../src/components/AutoScroll.ts","webpack://embla-carousel-docs/../src/components/utils.ts","webpack://embla-carousel-docs/./src/components/Sandbox/React/SandboxFilesSrc/AutoScroll/EmblaCarousel.tsx"],"sourcesContent":["import { CreateOptionsType } from 'embla-carousel'\n\nexport type RootNodeType =\n  | null\n  | ((emblaRoot: HTMLElement) => HTMLElement | null)\n\nexport type OptionsType = CreateOptionsType<{\n  direction: 'forward' | 'backward'\n  speed: number\n  startDelay: number\n  playOnInit: boolean\n  stopOnFocusIn: boolean\n  stopOnInteraction: boolean\n  stopOnMouseEnter: boolean\n  rootNode: RootNodeType\n}>\n\nexport const defaultOptions: OptionsType = {\n  direction: 'forward',\n  speed: 2,\n  startDelay: 1000,\n  active: true,\n  breakpoints: {},\n  playOnInit: true,\n  stopOnFocusIn: true,\n  stopOnInteraction: true,\n  stopOnMouseEnter: false,\n  rootNode: null\n}\n","import { OptionsType, defaultOptions } from './Options'\nimport { getAutoScrollRootNode } from './utils'\nimport {\n  CreatePluginType,\n  OptionsHandlerType,\n  EmblaCarouselType,\n  EngineType,\n  ScrollBodyType\n} from 'embla-carousel'\n\ndeclare module 'embla-carousel' {\n  interface EmblaPluginsType {\n    autoScroll: AutoScrollType\n  }\n\n  interface EmblaEventListType {\n    autoScrollPlay: 'autoScroll:play'\n    autoScrollStop: 'autoScroll:stop'\n  }\n}\n\nexport type AutoScrollType = CreatePluginType<\n  {\n    play: (delay?: number) => void\n    stop: () => void\n    reset: () => void\n    isPlaying: () => boolean\n  },\n  OptionsType\n>\n\nexport type AutoScrollOptionsType = AutoScrollType['options']\n\nfunction AutoScroll(userOptions: AutoScrollOptionsType = {}): AutoScrollType {\n  let options: OptionsType\n  let emblaApi: EmblaCarouselType\n  let destroyed: boolean\n  let startDelay: number\n  let timerId = 0\n  let autoScrollActive = false\n  let mouseIsOver = false\n  let defaultScrollBehaviour: ScrollBodyType\n\n  function init(\n    emblaApiInstance: EmblaCarouselType,\n    optionsHandler: OptionsHandlerType\n  ): void {\n    emblaApi = emblaApiInstance\n\n    const { mergeOptions, optionsAtMedia } = optionsHandler\n    const optionsBase = mergeOptions(defaultOptions, AutoScroll.globalOptions)\n    const allOptions = mergeOptions(optionsBase, userOptions)\n    options = optionsAtMedia(allOptions)\n\n    if (emblaApi.scrollSnapList().length <= 1) return\n\n    startDelay = options.startDelay\n    destroyed = false\n    defaultScrollBehaviour = emblaApi.internalEngine().scrollBody\n\n    const { eventStore } = emblaApi.internalEngine()\n    const isDraggable = !!emblaApi.internalEngine().options.watchDrag\n    const root = getAutoScrollRootNode(emblaApi, options.rootNode)\n\n    if (isDraggable) {\n      emblaApi.on('pointerDown', pointerDown)\n    }\n\n    if (isDraggable && !options.stopOnInteraction) {\n      emblaApi.on('pointerUp', pointerUp)\n    }\n\n    if (options.stopOnMouseEnter) {\n      eventStore.add(root, 'mouseenter', mouseEnter)\n    }\n\n    if (options.stopOnMouseEnter && !options.stopOnInteraction) {\n      eventStore.add(root, 'mouseleave', mouseLeave)\n    }\n\n    if (options.stopOnFocusIn) {\n      emblaApi.on('slideFocusStart', stopAutoScroll)\n    }\n\n    if (options.stopOnFocusIn && !options.stopOnInteraction) {\n      eventStore.add(emblaApi.containerNode(), 'focusout', startAutoScroll)\n    }\n\n    if (options.playOnInit) startAutoScroll()\n  }\n\n  function destroy(): void {\n    emblaApi\n      .off('pointerDown', pointerDown)\n      .off('pointerUp', pointerUp)\n      .off('slideFocusStart', stopAutoScroll)\n      .off('settle', settle)\n\n    stopAutoScroll()\n    destroyed = true\n    autoScrollActive = false\n  }\n\n  function startAutoScroll(): void {\n    if (destroyed) return\n    if (autoScrollActive) return\n    emblaApi.emit('autoScroll:play')\n\n    const engine = emblaApi.internalEngine()\n    const { ownerWindow } = engine\n\n    timerId = ownerWindow.setTimeout(() => {\n      engine.scrollBody = createAutoScrollBehaviour(engine)\n      engine.animation.start()\n    }, startDelay)\n\n    autoScrollActive = true\n  }\n\n  function stopAutoScroll(): void {\n    if (destroyed) return\n    if (!autoScrollActive) return\n    emblaApi.emit('autoScroll:stop')\n\n    const engine = emblaApi.internalEngine()\n    const { ownerWindow } = engine\n\n    engine.scrollBody = defaultScrollBehaviour\n    ownerWindow.clearTimeout(timerId)\n    timerId = 0\n\n    autoScrollActive = false\n  }\n\n  function createAutoScrollBehaviour(engine: EngineType): ScrollBodyType {\n    const {\n      location,\n      previousLocation,\n      offsetLocation,\n      target,\n      scrollTarget,\n      index,\n      indexPrevious,\n      limit: { reachedMin, reachedMax, constrain },\n      options: { loop }\n    } = engine\n    const directionSign = options.direction === 'forward' ? -1 : 1\n    const noop = (): ScrollBodyType => self\n\n    let bodyVelocity = 0\n    let scrollDirection = 0\n    let rawLocation = location.get()\n    let rawLocationPrevious = 0\n    let hasSettled = false\n\n    function seek(): ScrollBodyType {\n      let directionDiff = 0\n\n      previousLocation.set(location)\n\n      bodyVelocity = directionSign * options.speed\n      rawLocation += bodyVelocity\n      location.add(bodyVelocity)\n      target.set(location)\n\n      directionDiff = rawLocation - rawLocationPrevious\n      scrollDirection = Math.sign(directionDiff)\n      rawLocationPrevious = rawLocation\n\n      const currentIndex = scrollTarget.byDistance(0, false).index\n\n      if (index.get() !== currentIndex) {\n        indexPrevious.set(index.get())\n        index.set(currentIndex)\n        emblaApi.emit('select')\n      }\n\n      const reachedEnd =\n        options.direction === 'forward'\n          ? reachedMin(offsetLocation.get())\n          : reachedMax(offsetLocation.get())\n\n      if (!loop && reachedEnd) {\n        hasSettled = true\n        const constrainedLocation = constrain(location.get())\n        location.set(constrainedLocation)\n        target.set(location)\n        stopAutoScroll()\n      }\n\n      return self\n    }\n\n    const self: ScrollBodyType = {\n      direction: () => scrollDirection,\n      duration: () => -1,\n      velocity: () => bodyVelocity,\n      settled: () => hasSettled,\n      seek,\n      useBaseFriction: noop,\n      useBaseDuration: noop,\n      useFriction: noop,\n      useDuration: noop\n    }\n    return self\n  }\n\n  function pointerDown(): void {\n    if (!mouseIsOver) stopAutoScroll()\n  }\n\n  function pointerUp(): void {\n    if (!mouseIsOver) startAutoScrollOnSettle()\n  }\n\n  function mouseEnter(): void {\n    mouseIsOver = true\n    stopAutoScroll()\n  }\n\n  function mouseLeave(): void {\n    mouseIsOver = false\n    startAutoScroll()\n  }\n\n  function settle(): void {\n    emblaApi.off('settle', settle)\n    startAutoScroll()\n  }\n\n  function startAutoScrollOnSettle(): void {\n    emblaApi.on('settle', settle)\n  }\n\n  function play(startDelayOverride?: number): void {\n    if (typeof startDelayOverride !== 'undefined') {\n      startDelay = startDelayOverride\n    }\n    startAutoScroll()\n  }\n\n  function stop(): void {\n    if (autoScrollActive) stopAutoScroll()\n  }\n\n  function reset(): void {\n    if (autoScrollActive) {\n      stopAutoScroll()\n      startAutoScrollOnSettle()\n    }\n  }\n\n  function isPlaying(): boolean {\n    return autoScrollActive\n  }\n\n  const self: AutoScrollType = {\n    name: 'autoScroll',\n    options: userOptions,\n    init,\n    destroy,\n    play,\n    stop,\n    reset,\n    isPlaying\n  }\n  return self\n}\n\ndeclare namespace AutoScroll {\n  let globalOptions: AutoScrollOptionsType | undefined\n}\n\nAutoScroll.globalOptions = undefined\n\nexport default AutoScroll\n","import { EmblaCarouselType } from 'embla-carousel/components/EmblaCarousel'\nimport { RootNodeType } from './Options'\n\nexport function getAutoScrollRootNode(\n  emblaApi: EmblaCarouselType,\n  rootNode: RootNodeType\n): HTMLElement {\n  const emblaRootNode = emblaApi.rootNode()\n  return (rootNode && rootNode(emblaRootNode)) || emblaRootNode\n}\n","import React, { useCallback, useEffect, useState } from 'react'\nimport { EmblaOptionsType } from 'embla-carousel'\nimport useEmblaCarousel from 'embla-carousel-react'\nimport AutoScroll from 'embla-carousel-auto-scroll'\nimport {\n  NextButton,\n  PrevButton,\n  usePrevNextButtons\n} from '../EmblaCarouselArrowButtons'\n\ntype PropType = {\n  slides: number[]\n  options?: EmblaOptionsType\n}\n\nconst EmblaCarousel: React.FC<PropType> = (props) => {\n  const { slides, options } = props\n  const [emblaRef, emblaApi] = useEmblaCarousel(options, [\n    AutoScroll({ playOnInit: false })\n  ])\n  const [isPlaying, setIsPlaying] = useState(false)\n\n  const {\n    prevBtnDisabled,\n    nextBtnDisabled,\n    onPrevButtonClick,\n    onNextButtonClick\n  } = usePrevNextButtons(emblaApi)\n\n  const onButtonAutoplayClick = useCallback(\n    (callback: () => void) => {\n      const autoScroll = emblaApi?.plugins()?.autoScroll\n      if (!autoScroll) return\n\n      const resetOrStop =\n        autoScroll.options.stopOnInteraction === false\n          ? autoScroll.reset\n          : autoScroll.stop\n\n      resetOrStop()\n      callback()\n    },\n    [emblaApi]\n  )\n\n  const toggleAutoplay = useCallback(() => {\n    const autoScroll = emblaApi?.plugins()?.autoScroll\n    if (!autoScroll) return\n\n    const playOrStop = autoScroll.isPlaying()\n      ? autoScroll.stop\n      : autoScroll.play\n    playOrStop()\n  }, [emblaApi])\n\n  useEffect(() => {\n    const autoScroll = emblaApi?.plugins()?.autoScroll\n    if (!autoScroll) return\n\n    setIsPlaying(autoScroll.isPlaying())\n    emblaApi\n      .on('autoScroll:play', () => setIsPlaying(true))\n      .on('autoScroll:stop', () => setIsPlaying(false))\n      .on('reInit', () => setIsPlaying(autoScroll.isPlaying()))\n  }, [emblaApi])\n\n  return (\n    <div className=\"embla\">\n      <div className=\"embla__viewport\" ref={emblaRef}>\n        <div className=\"embla__container\">\n          {slides.map((index) => (\n            <div className=\"embla__slide\" key={index}>\n              <div className=\"embla__slide__number\">\n                <span>{index + 1}</span>\n              </div>\n            </div>\n          ))}\n        </div>\n      </div>\n\n      <div className=\"embla__controls\">\n        <div className=\"embla__buttons\">\n          <PrevButton\n            onClick={() => onButtonAutoplayClick(onPrevButtonClick)}\n            disabled={prevBtnDisabled}\n          />\n          <NextButton\n            onClick={() => onButtonAutoplayClick(onNextButtonClick)}\n            disabled={nextBtnDisabled}\n          />\n        </div>\n\n        <button className=\"embla__play\" onClick={toggleAutoplay} type=\"button\">\n          {isPlaying ? 'Stop' : 'Start'}\n        </button>\n      </div>\n    </div>\n  )\n}\n\nexport default EmblaCarousel\n"],"names":["defaultOptions","direction","speed","startDelay","active","breakpoints","playOnInit","stopOnFocusIn","stopOnInteraction","stopOnMouseEnter","rootNode","AutoScroll","userOptions","options","emblaApi","destroyed","defaultScrollBehaviour","timerId","autoScrollActive","mouseIsOver","startAutoScroll","emit","engine","internalEngine","ownerWindow","setTimeout","scrollBody","location","previousLocation","offsetLocation","target","scrollTarget","index","indexPrevious","limit","reachedMin","reachedMax","constrain","loop","directionSign","noop","self","bodyVelocity","scrollDirection","rawLocation","get","rawLocationPrevious","hasSettled","seek","directionDiff","set","add","Math","sign","currentIndex","byDistance","reachedEnd","constrainedLocation","stopAutoScroll","duration","velocity","settled","useBaseFriction","useBaseDuration","useFriction","useDuration","createAutoScrollBehaviour","animation","start","clearTimeout","pointerDown","pointerUp","startAutoScrollOnSettle","mouseEnter","mouseLeave","settle","off","on","name","init","emblaApiInstance","optionsHandler","mergeOptions","optionsAtMedia","optionsBase","globalOptions","allOptions","scrollSnapList","length","eventStore","isDraggable","watchDrag","root","emblaRootNode","getAutoScrollRootNode","containerNode","destroy","play","startDelayOverride","stop","reset","isPlaying","undefined","props","slides","emblaRef","useEmblaCarousel","setIsPlaying","useState","prevBtnDisabled","nextBtnDisabled","onPrevButtonClick","onNextButtonClick","usePrevNextButtons","onButtonAutoplayClick","useCallback","callback","_emblaApi$plugins","autoScroll","plugins","toggleAutoplay","_emblaApi$plugins2","useEffect","_emblaApi$plugins3","React","className","ref","map","key","PrevButton","onClick","disabled","NextButton","type"],"sourceRoot":""}