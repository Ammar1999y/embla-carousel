{"version":3,"file":"6655-d2f4edfeeed53ca4a1fb.js","mappings":"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","sources":["webpack://embla-carousel-docs/./src/components/Sandbox/React/SandboxFilesSrc/Autoplay/EmblaCarousel.tsx","webpack://embla-carousel-docs/../src/components/Options.ts","webpack://embla-carousel-docs/../src/components/Autoplay.ts"],"sourcesContent":["import React, { useCallback, useEffect, useState } from 'react'\nimport { EmblaOptionsType } from 'embla-carousel'\nimport useEmblaCarousel from 'embla-carousel-react'\nimport Autoplay from 'embla-carousel-autoplay'\nimport {\n  NextButton,\n  PrevButton,\n  usePrevNextButtons\n} from '../EmblaCarouselArrowButtons'\n\ntype PropType = {\n  slides: number[]\n  options?: EmblaOptionsType\n}\n\nconst EmblaCarousel: React.FC<PropType> = (props) => {\n  const { slides, options } = props\n  const [emblaRef, emblaApi] = useEmblaCarousel(options, [\n    Autoplay({ playOnInit: false, delay: 3000 })\n  ])\n  const [isPlaying, setIsPlaying] = useState(false)\n\n  const {\n    prevBtnDisabled,\n    nextBtnDisabled,\n    onPrevButtonClick,\n    onNextButtonClick\n  } = usePrevNextButtons(emblaApi)\n\n  const onButtonAutoplayClick = useCallback(\n    (callback: () => void) => {\n      const autoplay = emblaApi?.plugins()?.autoplay\n      if (!autoplay) return\n\n      const resetOrStop =\n        autoplay.options.stopOnInteraction === false\n          ? autoplay.reset\n          : autoplay.stop\n\n      resetOrStop()\n      callback()\n    },\n    [emblaApi]\n  )\n\n  const toggleAutoplay = useCallback(() => {\n    const autoplay = emblaApi?.plugins()?.autoplay\n    if (!autoplay) return\n\n    const playOrStop = autoplay.isPlaying() ? autoplay.stop : autoplay.play\n    playOrStop()\n  }, [emblaApi])\n\n  useEffect(() => {\n    const autoplay = emblaApi?.plugins()?.autoplay\n    if (!autoplay) return\n\n    setIsPlaying(autoplay.isPlaying())\n    emblaApi\n      .on('autoplay:play', () => setIsPlaying(true))\n      .on('autoplay:stop', () => setIsPlaying(false))\n      .on('reInit', () => setIsPlaying(false))\n  }, [emblaApi])\n\n  return (\n    <div className=\"embla\">\n      <div className=\"embla__viewport\" ref={emblaRef}>\n        <div className=\"embla__container\">\n          {slides.map((index) => (\n            <div className=\"embla__slide\" key={index}>\n              <div className=\"embla__slide__number\">\n                <span>{index + 1}</span>\n              </div>\n            </div>\n          ))}\n        </div>\n      </div>\n\n      <div className=\"embla__controls\">\n        <div className=\"embla__buttons\">\n          <PrevButton\n            onClick={() => onButtonAutoplayClick(onPrevButtonClick)}\n            disabled={prevBtnDisabled}\n          />\n          <NextButton\n            onClick={() => onButtonAutoplayClick(onNextButtonClick)}\n            disabled={nextBtnDisabled}\n          />\n        </div>\n\n        <button className=\"embla__play\" onClick={toggleAutoplay} type=\"button\">\n          {isPlaying ? 'Stop' : 'Start'}\n        </button>\n      </div>\n    </div>\n  )\n}\n\nexport default EmblaCarousel\n","import { CreateOptionsType } from 'embla-carousel/components/Options'\n\nexport type OptionsType = CreateOptionsType<{\n  delay: number\n  jump: boolean\n  playOnInit: boolean\n  stopOnFocusIn: boolean\n  stopOnInteraction: boolean\n  stopOnMouseEnter: boolean\n  stopOnLastSnap: boolean\n  rootNode: ((emblaRoot: HTMLElement) => HTMLElement | null) | null\n}>\n\nexport const defaultOptions: OptionsType = {\n  active: true,\n  breakpoints: {},\n  delay: 4000,\n  jump: false,\n  playOnInit: true,\n  stopOnFocusIn: true,\n  stopOnInteraction: true,\n  stopOnMouseEnter: false,\n  stopOnLastSnap: false,\n  rootNode: null\n}\n","import { OptionsType, defaultOptions } from './Options'\nimport { CreatePluginType } from 'embla-carousel/components/Plugins'\nimport { OptionsHandlerType } from 'embla-carousel/components/OptionsHandler'\nimport { EmblaCarouselType } from 'embla-carousel'\n\ndeclare module 'embla-carousel/components/Plugins' {\n  interface EmblaPluginsType {\n    autoplay?: AutoplayType\n  }\n}\n\ndeclare module 'embla-carousel/components/EventHandler' {\n  interface EmblaEventListType {\n    autoplayPlay: 'autoplay:play'\n    autoplayStop: 'autoplay:stop'\n  }\n}\n\nexport type AutoplayType = CreatePluginType<\n  {\n    play: (jump?: boolean) => void\n    stop: () => void\n    reset: () => void\n    isPlaying: () => boolean\n  },\n  OptionsType\n>\n\nexport type AutoplayOptionsType = AutoplayType['options']\n\nfunction Autoplay(userOptions: AutoplayOptionsType = {}): AutoplayType {\n  let options: OptionsType\n  let emblaApi: EmblaCarouselType\n  let destroyed: boolean\n  let playing = false\n  let resume = true\n  let jump = false\n  let animationFrame = 0\n  let timer = 0\n\n  function init(\n    emblaApiInstance: EmblaCarouselType,\n    optionsHandler: OptionsHandlerType\n  ): void {\n    emblaApi = emblaApiInstance\n\n    const { mergeOptions, optionsAtMedia } = optionsHandler\n    const optionsBase = mergeOptions(defaultOptions, Autoplay.globalOptions)\n    const allOptions = mergeOptions(optionsBase, userOptions)\n    options = optionsAtMedia(allOptions)\n\n    if (emblaApi.scrollSnapList().length <= 1) return\n\n    jump = options.jump\n    destroyed = false\n\n    const { eventStore, ownerDocument } = emblaApi.internalEngine()\n    const emblaRoot = emblaApi.rootNode()\n    const root = (options.rootNode && options.rootNode(emblaRoot)) || emblaRoot\n    const container = emblaApi.containerNode()\n\n    emblaApi.on('pointerDown', stopTimer)\n\n    if (!options.stopOnInteraction) {\n      emblaApi.on('pointerUp', startTimer)\n    }\n\n    if (options.stopOnMouseEnter) {\n      eventStore.add(root, 'mouseenter', () => {\n        resume = false\n        stopTimer()\n      })\n\n      if (!options.stopOnInteraction) {\n        eventStore.add(root, 'mouseleave', () => {\n          resume = true\n          startTimer()\n        })\n      }\n    }\n\n    if (options.stopOnFocusIn) {\n      eventStore.add(container, 'focusin', stopTimer)\n\n      if (!options.stopOnInteraction) {\n        eventStore.add(container, 'focusout', startTimer)\n      }\n    }\n\n    eventStore.add(ownerDocument, 'visibilitychange', visibilityChange)\n\n    if (options.playOnInit) {\n      emblaApi.on('init', startTimer).on('reInit', startTimer)\n    }\n  }\n\n  function destroy(): void {\n    emblaApi\n      .off('init', startTimer)\n      .off('reInit', startTimer)\n      .off('pointerDown', stopTimer)\n      .off('pointerUp', startTimer)\n    stopTimer()\n    cancelAnimationFrame(animationFrame)\n    animationFrame = 0\n    destroyed = true\n    playing = false\n  }\n\n  function startTimer(): void {\n    if (destroyed) return\n    if (!resume) return\n    if (!playing) emblaApi.emit('autoplay:play')\n    const { ownerWindow } = emblaApi.internalEngine()\n    ownerWindow.clearInterval(timer)\n    timer = ownerWindow.setInterval(next, options.delay)\n    playing = true\n  }\n\n  function stopTimer(): void {\n    if (destroyed) return\n    if (playing) emblaApi.emit('autoplay:stop')\n    const { ownerWindow } = emblaApi.internalEngine()\n    ownerWindow.clearInterval(timer)\n    timer = 0\n    playing = false\n  }\n\n  function visibilityChange(): void {\n    const { ownerDocument } = emblaApi.internalEngine()\n\n    if (ownerDocument.visibilityState === 'hidden') {\n      resume = playing\n      return stopTimer()\n    }\n\n    if (resume) startTimer()\n  }\n\n  function play(jumpOverride?: boolean): void {\n    if (typeof jumpOverride !== 'undefined') jump = jumpOverride\n    resume = true\n    startTimer()\n  }\n\n  function stop(): void {\n    if (playing) stopTimer()\n  }\n\n  function reset(): void {\n    if (playing) play()\n  }\n\n  function isPlaying(): boolean {\n    return playing\n  }\n\n  function next(): void {\n    animationFrame = requestAnimationFrame(() => {\n      const { index } = emblaApi.internalEngine()\n      const nextIndex = index.clone().add(1).get()\n      const lastIndex = emblaApi.scrollSnapList().length - 1\n      const kill = options.stopOnLastSnap && nextIndex === lastIndex\n\n      if (kill) stopTimer()\n\n      if (emblaApi.canScrollNext()) {\n        emblaApi.scrollNext(jump)\n      } else {\n        emblaApi.scrollTo(0, jump)\n      }\n    })\n  }\n\n  const self: AutoplayType = {\n    name: 'autoplay',\n    options: userOptions,\n    init,\n    destroy,\n    play,\n    stop,\n    reset,\n    isPlaying\n  }\n  return self\n}\n\nAutoplay.globalOptions = <AutoplayOptionsType | undefined>undefined\n\nexport default Autoplay\n"],"names":["props","slides","options","emblaRef","emblaApi","useEmblaCarousel","Autoplay","playOnInit","delay","isPlaying","setIsPlaying","useState","prevBtnDisabled","nextBtnDisabled","onPrevButtonClick","onNextButtonClick","usePrevNextButtons","onButtonAutoplayClick","useCallback","callback","_emblaApi$plugins","autoplay","plugins","stopOnInteraction","reset","stop","toggleAutoplay","_emblaApi$plugins2","play","useEffect","_emblaApi$plugins3","on","React","className","ref","map","index","key","PrevButton","onClick","disabled","NextButton","type","defaultOptions","active","breakpoints","jump","stopOnFocusIn","stopOnMouseEnter","stopOnLastSnap","rootNode","userOptions","destroyed","playing","resume","animationFrame","timer","startTimer","emit","ownerWindow","internalEngine","clearInterval","setInterval","next","stopTimer","visibilityChange","ownerDocument","visibilityState","jumpOverride","requestAnimationFrame","nextIndex","clone","add","get","lastIndex","scrollSnapList","length","canScrollNext","scrollNext","scrollTo","name","init","emblaApiInstance","optionsHandler","mergeOptions","optionsAtMedia","optionsBase","globalOptions","allOptions","eventStore","emblaRoot","root","container","containerNode","destroy","off","cancelAnimationFrame","undefined"],"sourceRoot":""}